#[=======================================================================[.rst:
TFAJsonUtilities
----------------

.. default-domain:: cmake

This module provides a number of utilities for manipulating JSON files. This
builds off of CMake's built-in support for JSON manipulation, provided by the
``JSON`` argument to the :command:`string <command:string>` function.

.. contents::

Getting/Setting
^^^^^^^^^^^^^^^

For JSON with a predefined structure, it's highly recommended that you
:ref:`generate accessors <Generating Accessors>` rather than attempting to
manipulate it manually.

.. command:: tfa_json_get

Retrieve and optionally decode a value from a JSON object.

.. code-block:: cmake

    tfa_json_get(<out-var> JSON <json> PATH <path>...
                 [DEFAULT <default>] [DECODE <STRING|ARRAY|MEMBERS>]
                 [ERROR_MESSAGE <error-message>])

This function reads an input JSON string ``<json>`` and sets ``<out-var>`` to
the JSON object retrieved from the path ``<path>...``. The object may optionally
be decoded with the decoder chosen by the ``DECODE`` argument. For documentation
on the available decoders and their behavior, see the :ref:`Encoding/Decoding`
section.

A default return value ``<default>`` may be provided should an error occur while
trying to retrieve the value. Alternatively, an error message
``<error-message>`` may be provided, which will override the default error
message.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     "name": "value"
    #   }
    # ]])

    tfa_json_get(value JSON "${json}" PATH "name")

    message(STATUS "${value}") # "value"

.. _Generating Accessors:

Generating Accessors
^^^^^^^^^^^^^^^^^^^^

Getter Generation
"""""""""""""""""

.. command:: tfa_json_getter

Define a getter for a JSON string with a pre-defined structure.

.. code-block:: cmake

    tfa_json_getter(<name> PATH <path>...
        [JSON <json>] [DECODE <STRING|ARRAY|MEMBERS>] [DEFAULT <default>]
        [ERROR_MESSAGE <error-message>][PARENT <parent>] [ARGUMENTS <arguments>]
        [PREPROCESS <preprocess>] [POSTPROCESS <postprocess>])

This macro generates a function ``<name>`` which gets a value via the path
``<path>`` from a JSON input. The JSON input may be provided directly to the
getter at the call site, or a default JSON input may be provided to this macro
via the ``<json>`` argument.

An alternative error message may be provided via the ``<error-message>``
argument, should you need to provide more user-facing information when parsing
errors occur. Alternatively, a default result may be provided via the
``<default>`` argument, in which case the given value will be returned and no
error emitted.

Basics
''''''

The getters generated by this macro behave similarly to :command:`tfa_json_get`.
They are of the following form:

.. code-block:: cmake

    <getter-name>(<out-var> [JSON <json>] <<getter-argument> <value>>...)

Where ``<getter-name>`` is the ``<name>`` argument given to the macro, and
``<getter-arguments>...`` are the ``<arguments>`` given to the macro.

By default, the value returned by the generated getter is itself a JSON value,
which can be further processed via other getters. If you need to decode this
value into a native CMake value, use the ``DECODE`` argument according to your
needs:

- ``STRING`` converts a JSON string into a native string.
- ``ARRAY`` converts a JSON array into a native list.
- ``MEMBERS`` converts a JSON object into a native list of its member names.

The following example demonstrates the result of each decoder:

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     "root": {
    #       "hello": "Hello, World!",
    #       "world": ["Hello", "World"]
    #     }
    #   }
    # ]])

    tfa_json_getter(get_members JSON "${json}" PATH "root" DECODE MEMBERS)
    tfa_json_getter(get_string JSON "${json}" PATH "root" "hello" DECODE STRING)
    tfa_json_getter(get_array JSON "${json}" PATH "root" "world" DECODE ARRAY)

    get_members(members)
    get_string(string)
    get_array(array)

    message(STATUS "${members}") # hello;world
    message(STATUS "${string}") # Hello, World!
    message(STATUS "${array}") # Hello;World

See :ref:`Encoding/Decoding` for more information on decoding JSON data.

The following example defines two JSON objects, and demonstrates how a string
value can be retrieved from multiple JSON sources via a single generated getter:

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(hello-world-json [[{ "say": { "something": "Hello, World!" } }]])
    # set(goodbye-world-json [[{ "say": { "something": "Goodbye, World!" } }]])

    tfa_json_getter(get_sentence PATH "say" "something"
        JSON "${hello-world-json}" DECODE STRING)

    get_sentence(hello-world)
    get_sentence(goodbye-world JSON "${goodbye-world-json}")

    message(STATUS "${hello-world}") # Hello, World!
    message(STATUS "${goodbye-world}") # Goodbye, World!

Getter Chaining
'''''''''''''''

A parent getter ``<parent>`` may optionally be provided to enable getter
chaining, whereby the generated getter first passes the JSON through the parent
getter before attempting to do its own JSON parsing.

For example, here three getters are chained together to parse an entire JSON
hierarchy:

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     "a": {
    #       "b": {
    #         "c": "d"
    #       }
    #     }
    #   }
    # ]])

    tfa_json_getter(get_a PATH "a")
    tfa_json_getter(get_b PATH "b" PARENT get_a)
    tfa_json_getter(get_c PATH "c" PARENT get_b)

    get_c(d JSON "${json}")

    message(STATUS "${d}") # "d"

When combined with getter chaining, the custom error message ``<error-message>``
enables more localized diagnostics in the case of an invalid JSON input. Here is
the previous example, but with a demonstration of how errors are propagated up
the getter chain:

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     a": {
    #       "???": {
    #         "c": "d"
    #       }
    #     }
    #   }
    # ]])

    tfa_json_getter(get_a JSON PATH "a" ERROR_MESSAGE "There is no a!")
    tfa_json_getter(get_b JSON PATH "b" ERROR_MESSAGE "There is no b!" PARENT get_a)
    tfa_json_getter(get_c JSON PATH "c" ERROR_MESSAGE "There is no c!" PARENT get_b)

    get_c(d JSON "${json}") # There is no b!

Parametrized Paths
''''''''''''''''''

In more complex JSON schemas, particularly with user-controlled JSON data, paths
often need to be parametrized. Parameters for the generated getter may be given
via ``<arguments>...``. These parameters can be referenced from the path by
using @-style variable references (``@VAR@``).

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     "a": {
    #       "value": "value of a"
    #     },
    #
    #     "b": {
    #       "value": "value of b"
    #     }
    #   }
    # ]])

    tfa_json_getter(get_value PATH "@OBJECT@" "value"
        ARGUMENTS OBJECT)

    get_value(value JSON "${json}" OBJECT b)

    message(STATUS "${value}") # "value of b"

Preprocessing and Postprocessing
''''''''''''''''''''''''''''''''

This macro also accepts a preprocessing macro ``<preprocessor>`` and a
postprocessing macro ``<postprocessor>``. These macros can be used to
directly manipulate the input JSON prior to passing it to the underlying getter,
and to manipulate the output before the result is returned to the caller.

As macros, these have full access to the generated function's scope. That means
they can directly manipulate the control flow of the function, and therefore
care must be taken such that they are only used when absolutely necessary, and
that when used they are kept as minimal as possible.

Note that the preprocessor is invoked *after* any parent getters have been
invoked.

The following example demonstrates usage of the preprocessor hook to build a
single getter chain which actually spans across two JSON objects:

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #     {
    #         "variable": "hello-world-json"
    #     }
    # ]])

    # set(hello-world-json [[
    #     {
    #         "message": "Hello, World!"
    #     }
    # ]])

    macro(dereference_variable)
        set(ARG_JSON "${${ARG_JSON}}")
    endmacro()

    tfa_json_getter(get_variable PATH "variable" DECODE STRING)
    tfa_json_getter(get_message PATH "message" DECODE STRING
        PARENT get_variable PREPROCESS dereference_variable)

    get_message(message JSON "${json}")

    message(STATUS "${message}") # Hello, World!

.. _Encoding/Decoding:

Encoding/Decoding
^^^^^^^^^^^^^^^^^

Some of the functions provided by this module may optionally perform an
additional encoding or decoding step, whereby a native CMake value may be
explicitly encoded in a given JSON format, or decoded from a JSON value to a
native CMake value.

Encoding
""""""""

Unitary Encoders
''''''''''''''''

.. command:: tfa_json_encode_string

Encode a CMake string as JSON.

.. code-block:: cmake

    tfa_json_encode_string(<out-var> <string>)

This function takes an input string ``<string>``, escapes it according to
section 9 of the ECMA-404 JSON Data Interchange Syntax specification, wraps
it in quotes (``"``), and writes the result to the variable ``<out-var>``.

The resulting value is suitable for insertion into a JSON object.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    tfa_json_encode_string(json "Hello, World!")

    message(STATUS "${json}") # "Hello, World!"

Decoding
""""""""

.. command:: tfa_json_decode

Decode a JSON object into some other native CMake form.

.. code-block:: cmake

    tfa_json_decode(<out-var> JSON <json> DECODE <MEMBERS|ARRAY|STRING>)

This function is a short-hand method for decoding a JSON value using the
:ref:`unitary decoders <Unitary Decoders>`.

.. _Unitary Decoders:

Unitary Decoders
''''''''''''''''

.. command:: tfa_json_decode_string

Decode a JSON string into a CMake string.

.. code-block:: cmake

    tfa_json_decode_string(<out-var> <string>)

This function takes a JSON string and decodes it into a regular string. Escaped
characters are unescaped automatically where possible.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[ "Hello, World!" ]])

    tfa_json_decode_string(string "${json}")

    message(STATUS "${string}") # Hello, World!

.. command:: tfa_json_decode_array

Decode a JSON array into a CMake list.

.. code-block:: cmake

    tfa_json_decode_array(<out-var> <array>)

This function takes an input JSON array ``<array>`` and returns a CMake list
representing the string entries in ``<out-var>``.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[ ["Hello", "World"] ]])

    tfa_json_decode_array(array "${json}")

    message(STATUS "${array}") # Hello;World

.. command:: tfa_json_decode_members

Decode a JSON object into a list of its member names.

.. code-block:: cmake

    tfa_json_decode_members(<out-var> <object>)

This function takes an input JSON object ``<object>`` and returns a CMake list
representing its member names in ``<out-var>``.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json [[
    #   {
    #     "a": "this is a",
    #     "b": "this is b",
    #     "c": "this is c"
    #   }
    # ]])

    tfa_json_decode_members(members "${json}")

    message(STATUS "${members}") # a;b;c

Merging Objects
^^^^^^^^^^^^^^^

.. command:: tfa_json_merge

Merge two JSON objects.

.. code-block:: cmake

    tfa_json_merge(<out-var> BOTTOM <bottom-json> TOP <top-json>
                   [BOTTOM_PATH <bottom-path>] [TOP_PATH <top-path>])

This function merges two JSON objects, ``<bottom-json>`` and ``<top-json>``,
such that the resulting JSON is the union of the two JSON objects, where any
conflicting objects are taken from the top JSON.

A JSON path, ``<bottom-path>`` or ``<top-path>``, may be used to select
alternative root paths for merging. This can be useful if you wish to merge only
a particular child node of one or both of the JSON objects.

.. code-block:: cmake
    :caption: Example usage
    :linenos:

    # set(json-bottom [[
    #   {
    #     "root": {
    #       "string": "a",
    #       "array": ["a", "b"],
    #       "object": {
    #         "a": {
    #           "x": null,
    #           "y": null
    #         }
    #       }
    #     }
    #   }
    # ]])

    # set(json-top [[
    #   {
    #     "string": "xyz",
    #     "array": ["x", "y", "z"],
    #     "object": {
    #       "a": {
    #         "y": null,
    #         "z": null
    #       },
    # 
    #       "b": {
    #         "x": null,
    #         "y": null,
    #         "z": null
    #       }
    #     }
    #   }
    # ]])

    tfa_json_merge(json
        BOTTOM "${json-bottom}" BOTTOM_PATH "root"
        TOP "${json-top}")

    message(STATUS "${json}")

    # {
    #   "root": {
    #     "string" : "xyz",
    #     "array": [ "x", "y", "z" ],
    #     "object": {
    #       "a": {
    #         "x" : null,
    #         "y" : null,
    #         "z" : null
    #       },
    #       "b": {
    #         "x" : null,
    #         "y" : null,
    #         "z" : null
    #       }
    #     }
    #   }
    # }
#]=======================================================================]

include(ArmAssert)
include(ArmExpand)

#
# Decode a string by stripping the outer quote marks and replacing escaped
# special characters with their real characters.
#

function(tfa_json_decode_string out-var string)
    string(REGEX REPLACE [["(.*)"]] [[\1]] string "${string}")

    string(REPLACE [[\"]] "\"" string "${string}")
    string(REPLACE [[\\]] "\\" string "${string}")
    string(REPLACE [[\t]] "\t" string "${string}")
    string(REPLACE [[\r]] "\r" string "${string}")
    string(REPLACE [[\n]] "\n" string "${string}")

    set(${out-var} "${string}" PARENT_SCOPE)
endfunction()

#
# Encode a string by replacing certain special characters with escaped versions
# and wrapping the string in quote marks, according to the rules of ECMA-404.
#

function(tfa_json_encode_string out-var string)
    string(REPLACE "\"" [[\"]] string "${string}")
    string(REPLACE "\\" [[\\]] string "${string}")
    string(REPLACE "\t" [[\t]] string "${string}")
    string(REPLACE "\r" [[\r]] string "${string}")
    string(REPLACE "\n" [[\n]] string "${string}")

    set(${out-var} "\"${string}\"" PARENT_SCOPE)
endfunction()

#
# Decode an array by iterating through the entries of the input JSON array value
# and pushing each of them to the back of a new list.
#

function(tfa_json_decode_array out-var array)
    set(out "")

    string(JSON length ERROR_VARIABLE error LENGTH "${array}" )
    arm_assert(CONDITION NOT error MESSAGE "${error}")

    if(length GREATER 0)
        math(EXPR n "${length} - 1")

        foreach(i RANGE ${n})
            string(JSON entry ERROR_VARIABLE error GET "${array}" ${i})
            arm_assert(CONDITION NOT error MESSAGE "${error}")

            list(APPEND out "${entry}")
        endforeach()
    endif()

    set(${out-var} "${out}" PARENT_SCOPE)
endfunction()

#
# Decode the member names of an object by iterating over the length of the
# object and pushing the name of the member at each index to the back of a new
# list.
#

function(tfa_json_decode_members out-var object)
    set(members "")

    string(JSON length ERROR_VARIABLE error LENGTH "${object}")
    arm_assert(CONDITION NOT error MESSAGE "${error}")

    if(length GREATER 0)
        math(EXPR n "${length} - 1")

        foreach(i RANGE ${n})
            string(JSON member ERROR_VARIABLE error MEMBER "${object}" ${i})
            arm_assert(CONDITION NOT error MESSAGE "${error}")

            list(APPEND members "${member}")
        endforeach()
    endif()

    set(${out-var} "${members}" PARENT_SCOPE)
endfunction()

#
# Decode any JSON value according to the decode type passed via an argument.
# This simplifies the decoding step in some other utility functions,
# particularly when dealing with JSON values of different types.
#

function(tfa_json_decode out-var)
    set(options)
    set(single-args JSON DECODE)
    set(multi-args)

    cmake_parse_arguments(PARSE_ARGV 1 ARG
        "${options}" "${single-args}" "${multi-args}")

    arm_assert(
        CONDITION DEFINED ARG_JSON
        MESSAGE "Please provide the JSON to decode via the `JSON` argument.")

    arm_assert(
        CONDITION ARG_DECODE MATCHES "^(MEMBERS|ARRAY|STRING)$"
        MESSAGE "The `DECODE` argument accepts only the following values:\n"
                " - `MEMBERS` to decode object member names\n"
                " - `ARRAY` to decode array values\n"
                " - `STRING` to decode string values")

    if(ARG_DECODE STREQUAL "MEMBERS")
        tfa_json_decode_members(value "${ARG_JSON}")
    elseif(ARG_DECODE STREQUAL "ARRAY")
        tfa_json_decode_array(value "${ARG_JSON}")
    elseif(ARG_DECODE STREQUAL "STRING")
        tfa_json_decode_string(value "${ARG_JSON}")
    endif()

    set(${out-var} "${value}" PARENT_SCOPE)
endfunction()

#
# Retrieve the JSON value at a given path for a given JSON string, and
# optionally decode it into a natively-supported CMake value or list.
#

function(tfa_json_get out-var)
    set(options)
    set(single-args JSON DEFAULT DECODE)
    set(multi-args PATH ERROR_MESSAGE)

    cmake_parse_arguments(PARSE_ARGV 1 ARG
        "${options}" "${single-args}" "${multi-args}")

    arm_assert(CONDITION DEFINED ARG_JSON)

    string(JSON value ERROR_VARIABLE error
        GET "${ARG_JSON}" ${ARG_PATH})
    if(error)
        if(DEFINED ARG_ERROR_MESSAGE)
            set(error "${ARG_ERROR_MESSAGE}")
        endif()

        arm_assert(
            CONDITION DEFINED ARG_DEFAULT
            MESSAGE ${error})

        set(value "${ARG_DEFAULT}")
    else()
        if(DEFINED ARG_DECODE)
            if(NOT ARG_DECODE STREQUAL "STRING")
                #
                # CMake decodes strings automatically. Therefore, we do not do
                # anything if the user has asked for a decoded string value.
                #

                tfa_json_decode(value JSON "${value}" DECODE "${ARG_DECODE}")
            endif()
        else()
            string(JSON type TYPE "${ARG_JSON}" ${ARG_PATH})

            #
            # Opposite to the above, we need to re-encode string values unless
            # the user has explicitly asked for them to be decoded. This way,
            # all values returned by this function are valid JSON values only
            # unless decoding has been requested.
            #

            if(type STREQUAL "STRING")
                tfa_json_encode_string(value "${value}")
            endif()
        endif()
    endif()

    set(${out-var} "${value}" PARENT_SCOPE)
endfunction()

#
# Generate accessor functions for metadata objects.
#
# Keep in mind the behavior of macro arguments versus variables here - macro
# arguments (`ARGN`, `ARGV`, `ARGC`, etc.) are all treated as text replacements,
# but variables persist after the macro has ended and will be read by the
# function when invoked.
#
# As such, we need to save the variables we wish to persist to the function
# under unique names, which we do by prefixing them with the getter name. If we
# didn't do that, the variables would be overwritten every time this function
# was called.
#

macro(tfa_json_getter name)
    set(options)
    set(single-args JSON PARENT DECODE DEFAULT)
    set(multi-args PATH ARGUMENTS ERROR_MESSAGE PREPROCESS POSTPROCESS)

    cmake_parse_arguments(${name}_ARG
        "${options}" "${single-args}" "${multi-args}" ${ARGN})

    #
    # Pick up the user arguments required by our parent and add them to our own
    # list of user arguments.
    #

    if(DEFINED ${name}_ARG_PARENT)
        arm_assert(
            CONDITION COMMAND ${${name}_ARG_PARENT}
            MESSAGE "The `${name}` JSON getter cannot be created before its "
                    "parent getter (`${${name}_ARG_PARENT}`).")

        list(APPEND ${name}_ARG_ARGUMENTS ${${${name}_ARG_PARENT}_ARG_ARGUMENTS})
    endif()

    function(${name} out-var)
        set(options)
        set(single-args JSON ${${name}_ARG_ARGUMENTS})
        set(multi-args)

        cmake_parse_arguments(PARSE_ARGV 1 ARG
            "${options}" "${single-args}" "${multi-args}")

        #
        # Allow the user to provide the JSON to read from, and otherwise fall
        # back to the one provided by the generator (if one was provided).
        #

        if((NOT DEFINED ARG_JSON) AND (DEFINED ${name}_ARG_JSON))
            set(ARG_JSON "${${name}_ARG_JSON}")
        endif()

        arm_assert(
            CONDITION DEFINED ARG_JSON
            MESSAGE "Please provide the JSON string to operate on via the "
                    "`JSON` argument.")

        #
        # Strip the `ARG_` prefix from getter arguments that the user has
        # specified. This allows the user to provide an error message
        # referencing the name of the argument directly, rather than depending
        # on implementation details about how the argument is provided.
        #

        foreach(argument IN LISTS ${name}_ARG_ARGUMENTS)
            arm_assert(
                CONDITION DEFINED ARG_${argument}
                MESSAGE "Please provide a value for the `${argument}` argument.")

            set(${argument} "${ARG_${argument}}")
        endforeach()

        #
        # Because the node path might contain references to arguments passed to
        # the getter, we need to ensure we run a variable expansion over it.
        #

        arm_expand(OUTPUT ${name}_ARG_PATH ATONLY
            STRING "${${name}_ARG_PATH}")

        #
        # Expand the error message so that users can use the value of
        # user-provided arguments in their error messages.
        #

        if(DEFINED ${name}_ARG_ERROR_MESSAGE)
            arm_expand(OUTPUT ${name}_ARG_ERROR_MESSAGE ATONLY
                STRING "${${name}_ARG_ERROR_MESSAGE}")
        endif()

        #
        # If a parent getter has been assigned, invoke it and retrieve the
        # JSON object. This climbs all the ancestors of the node we're trying to
        # get, passing along all the arguments we've been given on the way up.
        #

        if(DEFINED ${name}_ARG_PARENT)
            set(_ARGN ARGN) # Normal `${ARGN}` will be macro-replaced!

            cmake_language(CALL "${${name}_ARG_PARENT}" ARG_JSON ${${_ARGN}})
        endif()

        #
        # If a preprocess macro has been provided, invoke it. Note that it will
        # almost certainly mutate the environment.
        #

        if(DEFINED ${name}_ARG_PREPROCESS)
            cmake_language(CALL "${${name}_ARG_PREPROCESS}")
        endif()

        #
        # Now retrieve the node from the JSON. We explicitly forward some
        # arguments passed to us: `DECODE`, `DEFAULT` and `ERROR_MESSAGE`.
        #

        set(forwarded-args "")

        foreach(forward-arg IN ITEMS DECODE DEFAULT ERROR_MESSAGE)
            if(DEFINED ${name}_ARG_${forward-arg})
                list(APPEND forwarded-args ${forward-arg}
                    "${${name}_ARG_${forward-arg}}")
            endif()
        endforeach()

        tfa_json_get(value JSON "${ARG_JSON}" PATH ${${name}_ARG_PATH}
            ${forwarded-args})

        #
        # If a postprocess macro has been provided, invoke it. This behaves
        # exactly like the preprocess invocation.
        #

        if(DEFINED ${name}_ARG_POSTPROCESS)
            cmake_language(CALL "${${name}_ARG_POSTPROCESS}")
        endif()

        set(${out-var} "${value}" PARENT_SCOPE)
    endfunction()
endmacro()

function(tfa_json_merge out-var)
    set(options "")
    set(single-args "BOTTOM;TOP")
    set(multi-args "BOTTOM_PATH;TOP_PATH")

    cmake_parse_arguments(PARSE_ARGV 0 ARG
        "${options}" "${single-args}" "${multi-args}")

    arm_assert(
        CONDITION DEFINED ARG_BOTTOM
        MESSAGE "The `BOTTOM` argument must be provided.")

    arm_assert(
        CONDITION DEFINED ARG_TOP
        MESSAGE "The `TOP` argument must be provided.")

    string(JSON type ERROR_VARIABLE error TYPE "${ARG_TOP}" ${ARG_TOP_PATH})
    arm_assert(CONDITION NOT error MESSAGE "${error}")

    if(type STREQUAL "OBJECT")
        tfa_json_get(bottom-keys JSON "${ARG_BOTTOM}" DECODE MEMBERS
            PATH ${ARG_BOTTOM_PATH})
        tfa_json_get(top-keys JSON "${ARG_TOP}" DECODE MEMBERS
            PATH ${ARG_TOP_PATH})

        foreach(key IN LISTS top-keys)
            string(JSON top-type TYPE "${ARG_TOP}" ${ARG_TOP_PATH} "${key}")
            string(JSON top-value GET "${ARG_TOP}" ${ARG_TOP_PATH} "${key}")

            if(top-type STREQUAL "STRING")
                tfa_json_encode_string(top-value "${top-value}")
            endif()

            if((key IN_LIST bottom-keys) AND (top-type STREQUAL "OBJECT"))
                string(JSON bottom-type TYPE "${ARG_BOTTOM}"
                    ${ARG_BOTTOM_PATH} "${key}")
                string(JSON bottom-value GET "${ARG_BOTTOM}"
                    ${ARG_BOTTOM_PATH} "${key}")

                if(bottom-type STREQUAL "STRING")
                    tfa_json_encode_string(bottom-value "${bottom-value}")
                endif()

                tfa_json_merge(bottom-value
                    BOTTOM "${bottom-value}"
                    TOP "${top-value}"
                    TOP_PATH ${ARG_TOP_PATH})
            else()
                set(bottom-value "${top-value}")
            endif()

            if(bottom-value STREQUAL "")
                set(bottom-value "null")
            endif()

            string(JSON ARG_BOTTOM ERROR_VARIABLE error SET "${ARG_BOTTOM}"
                ${ARG_BOTTOM_PATH} "${key}" "${bottom-value}")
            arm_assert(CONDITION NOT error MESSAGE "${error}")
        endforeach()

        set("${out-var}" "${ARG_BOTTOM}" PARENT_SCOPE)
    else()
        set("${out-var}" "${ARG_TOP}" PARENT_SCOPE)
    endif()
endfunction()
